<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Pandoc - Pandoc filters</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!--[if lt IE 9]>
       <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
       <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
       <![endif]-->
  <link rel="stylesheet"
          href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="css/screen.css">
  <link rel="stylesheet" type="text/css" media="print" href="css/print.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      pre{ font-size: 12pt; }
      .smallcaps{font-variant: small-caps;}
      .line-block{white-space: pre-line;}
      .column{display: inline-block;}
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  { background-color: #f8f8f8; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"
            type="text/javascript"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
  <script src="js/nav.js"></script>
  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2234613-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  </script>
  <script type="text/javascript">
  /* <![CDATA[ */
    (function() {
        var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
        s.type = 'text/javascript';
        s.async = true;
        s.src = 'https://api.flattr.com/js/0.6/load.js?mode=auto';
        t.parentNode.insertBefore(s, t);
    })();
  /* ]]> */
  </script>
</head>
<body>
  <div id="doc" class="container-fluid">
    <header>
      <div id="flattr">
        <a class="FlattrButton" style="display:none;" rev="flattr;button:compact;" href="https://pandoc.org"></a>
        <noscript><a href="https://flattr.com/thing/936364/Pandoc" target="_blank"><img src="https://api.flattr.com/button/flattr-badge-large.png" alt="Flattr this" title="Flattr this" border="0" /></a></noscript>
      </div>
        <div id="paypal">
         <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----
">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
<img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
      </div>

        <span class="big">Pandoc</span>
        &nbsp;
        <span class="small">a universal document converter</span>
    </header>
    <div id="bd">
      <nav id="navbar" class="navbar nav navbar-default col-md-3 col-sm-4">
        <div class="navbar-header">
  <button type="button" class="navbar-toggle"
          data-toggle="collapse"
          data-target=".navbar-collapse">
    <span class="sr-only">Toggle navigation</span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
</div>
<div class="navbar-collapse collapse">
  <ul class="nav tree">
    <li><a href="index.html">About</a></li>
    <li><a href="installing.html">Installing</a></li>
    <li><a href="getting-started.html">Getting started</a></li>
    <li><a class="tree-toggle nav-header">Demos</a>
    <ul class="nav tree">
      <li><a href="try">Try pandoc online</a></li>
      <li><a href="demos.html">Examples</a></li>
    </ul>
    </li>
    <li><a class="tree-toggle nav-header">Documentation</a>
    <ul class="nav tree">
      <li><a href="MANUAL.html">User's Guide</a>
      <li><a href="MANUAL.pdf">User's Guide (PDF)</a>
      <li><a href="epub.html">Making an ebook</a></li>
      <li><a href="filters.html">Filters</a></li>
      <li><a href="lua-filters.html">Lua filters</a></li>
      <li><a href="CONTRIBUTING.html">Contributing</a></li>
      <li><a href="faqs.html">FAQ</a></li>
      <li><a href="press.html">Press</a></li>
      <li><a href="using-the-pandoc-api.html">Using the Pandoc API</a></li>
      <li><a href="http://hackage.haskell.org/package/pandoc">API documentation</a></li>
    </ul>
    </li>
    <li><a href="help.html">Help</a></li>
    <li><a href="https://github.com/jgm/pandoc/wiki/Pandoc-Extras">Extras</a></li>
    <li><a href="releases.html">Releases</a></li>
  </ul>
</div>
      </nav>
      <main class="col-md-9 col-sm-8">
        <div class="row">
          <h1 class="title">Pandoc filters</h1>
        <div id="toc">
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#a-simple-example">A simple example</a></li>
<li><a href="#queries-listing-urls">Queries: listing URLs</a></li>
<li><a href="#json-filters">JSON filters</a></li>
<li><a href="#latex-for-wordpress">LaTeX for WordPress</a></li>
<li><a href="#but-i-dont-want-to-learn-haskell">But I don’t want to learn Haskell!</a></li>
<li><a href="#include-files">Include files</a></li>
<li><a href="#removing-links">Removing links</a></li>
<li><a href="#a-filter-for-ruby-text">A filter for ruby text</a></li>
<li><a href="#exercises">Exercises</a></li>
</ul>
        </div>
<h1 id="summary">Summary</h1>
<p>Pandoc provides an interface for users to write programs (known as filters) which act on pandoc’s AST.</p>
<p>Pandoc consists of a set of readers and writers. When converting a document from one format to another, text is parsed by a reader into pandoc’s intermediate representation of the document—an “abstract syntax tree” or AST—which is then converted by the writer into the target format. The pandoc AST format is defined in the module <code>Text.Pandoc.Definition</code> in <a href="https://hackage.haskell.org/package/pandoc-types">pandoc-types</a>.</p>
<p>A “filter” is a program that modifies the AST, between the reader and the writer:</p>
<pre><code>INPUT --reader--&gt; AST --filter--&gt; AST --writer--&gt; OUTPUT</code></pre>
<p>Filters are “pipes” that read from standard input and write to standard output. They consume and produce a JSON representation of the pandoc AST. (In recent versions, this representation includes a <code>pandoc-api-version</code> field which refers to a version of <code>pandoc-types</code>.) Filters may be written in any programming language. To use a filter, you need only specify it on the command line using <code>--filter</code>, e.g.</p>
<pre><code>pandoc -s input.txt --filter pandoc-citeproc -o output.htl</code></pre>
<p>For a gentle introduction into writing your own filters, continue this guide. There’s also a <a href="https://github.com/jgm/pandoc/wiki/Pandoc-Filters">list of third party filters on the wiki</a>.</p>
<h1 id="a-simple-example">A simple example</h1>
<p>Suppose you wanted to replace all level 2+ headers in a markdown document with regular paragraphs, with text in italics. How would you go about doing this?</p>
<p>A first thought would be to use regular expressions. Something like this:</p>
<pre><code>perl -pe &#39;s/^##+ (.*)$/\*\1\*/&#39; source.txt</code></pre>
<p>This should work most of the time. But don’t forget that ATX style headers can end with a sequence of <code>#</code>s that is not part of the header text:</p>
<pre><code>## My header ##</code></pre>
<p>And what if your document contains a line starting with <code>##</code> in an HTML comment or delimited code block?</p>
<pre><code>&lt;!--
## This is just a comment
--&gt;

~~~~
### A third level header in standard markdown
~~~~</code></pre>
<p>We don’t want to touch <em>these</em> lines. Moreover, what about setext style second-level headers?</p>
<pre><code>A header
--------</code></pre>
<p>We need to handle those too. Finally, can we be sure that adding asterisks to each side of our string will put it in italics? What if the string already contains asterisks around it? Then we’ll end up with bold text, which is not what we want. And what if it contains a regular unescaped asterisk?</p>
<p>How would you modify your regular expression to handle these cases? It would be hairy, to say the least. What we need is a real parser.</p>
<p>Well, pandoc has a real markdown parser, the library function <code>readMarkdown</code>. This transforms markdown text to an abstract syntax tree (AST) that represents the document structure. Why not manipulate the AST directly in a short Haskell script, then convert the result back to markdown using <code>writeMarkdown</code>?</p>
<p>First, let’s see what this AST looks like. We can use pandoc’s <code>native</code> output format:</p>
<pre><code>% cat test.txt
## my header

text with *italics*
% pandoc -s -t native test.txt
Pandoc (Meta {unMeta = fromList []})
[Header 3 (&quot;my-header&quot;,[],[]) [Str &quot;My&quot;,Space,Str &quot;header&quot;]
, Para [Str &quot;text&quot;,Space,Str &quot;with&quot;,Space,Emph [Str &quot;italics&quot;]] ]</code></pre>
<p>A <code>Pandoc</code> document consists of a <code>Meta</code> block (containing metadata like title, authors, and date) and a list of <code>Block</code> elements. In this case, we have two <code>Block</code>s, a <code>Header</code> and a <code>Para</code>. Each has as its content a list of <code>Inline</code> elements. For more details on the pandoc AST, see the <a href="http://hackage.haskell.org/package/pandoc-types">haddock documentation for <code>Text.Pandoc.Definition</code></a>.</p>
<p>Here’s a short Haskell script that reads markdown, changes level 2+ headers to regular paragraphs, and writes the result as markdown. If you save it as <code>behead.hs</code>, you can run it using <code>runhaskell behead.hs</code>. It will act like a unix pipe, reading from <code>stdin</code> and writing to <code>stdout</code>. Or, if you want, you can compile it, using <code>ghc --make behead</code>, then run the resulting executable <code>behead</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- behead.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Text.Pandoc</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Text.Pandoc.Walk</span> (walk)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ot">behead ::</span> <span class="dt">Block</span> <span class="ot">-&gt;</span> <span class="dt">Block</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">behead (<span class="dt">Header</span> n _ xs) <span class="fu">|</span> n <span class="fu">&gt;=</span> <span class="dv">2</span> <span class="fu">=</span> <span class="dt">Para</span> [<span class="dt">Emph</span> xs]</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">behead x <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="ot">readDoc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Pandoc</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">readDoc s <span class="fu">=</span> readMarkdown def s</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="co">-- or, for pandoc 1.14 and greater, use:</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="co">-- readDoc s = case readMarkdown def s of</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="co">--                  Right doc -&gt; doc</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="co">--                  Left err  -&gt; error (show err)</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"></a>
<a class="sourceLine" id="cb8-16" data-line-number="16"><span class="ot">writeDoc ::</span> <span class="dt">Pandoc</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">writeDoc doc <span class="fu">=</span> writeMarkdown def doc</a>
<a class="sourceLine" id="cb8-18" data-line-number="18"></a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">main <span class="fu">=</span> interact (writeDoc <span class="fu">.</span> walk behead <span class="fu">.</span> readDoc)</a></code></pre></div>
<p>The magic here is the <code>walk</code> function, which converts our <code>behead</code> function (a function from <code>Block</code> to <code>Block</code>) to a transformation on whole <code>Pandoc</code> documents. (See the <a href="http://hackage.haskell.org/package/pandoc-types">haddock documentation for <code>Text.Pandoc.Walk</code></a>.)</p>
<h1 id="queries-listing-urls">Queries: listing URLs</h1>
<p>We can use this same technique to do much more complex transformations and queries. Here’s how we could extract all the URLs linked to in a markdown document (again, not an easy task with regular expressions):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">-- extracturls.hs</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Text.Pandoc</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="ot">extractURL ::</span> <span class="dt">Inline</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">extractURL (<span class="dt">Link</span> _ _ (u,_)) <span class="fu">=</span> [u]</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">extractURL (<span class="dt">Image</span> _ _ (u,_)) <span class="fu">=</span> [u]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">extractURL _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="ot">extractURLs ::</span> <span class="dt">Pandoc</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">extractURLs <span class="fu">=</span> query extractURL</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="ot">readDoc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Pandoc</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">readDoc <span class="fu">=</span> readMarkdown def</a>
<a class="sourceLine" id="cb9-14" data-line-number="14"><span class="co">-- or, for pandoc 1.14, use:</span></a>
<a class="sourceLine" id="cb9-15" data-line-number="15"><span class="co">-- readDoc s = case readMarkdown def s of</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="co">--                Right doc -&gt; doc</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17"><span class="co">--                Left err  -&gt; error (show err)</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18"></a>
<a class="sourceLine" id="cb9-19" data-line-number="19"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">main <span class="fu">=</span> interact (unlines <span class="fu">.</span> extractURLs <span class="fu">.</span> readDoc)</a></code></pre></div>
<p><code>query</code> is the query counterpart of <code>walk</code>: it lifts a function that operates on <code>Inline</code> elements to one that operates on the whole <code>Pandoc</code> AST. The results returned by applying <code>extractURL</code> to each <code>Inline</code> element are concatenated in the result.</p>
<h1 id="json-filters">JSON filters</h1>
<p><code>behead.hs</code> is a very special-purpose program. It reads a specific input format (markdown) and writes a specific output format (HTML), with a specific set of options (here, the defaults). But the basic operation it performs is one that would be useful in many document transformations. It would be nice to isolate the part of the program that transforms the pandoc AST, leaving the rest to pandoc itself. What we want is a <em>filter</em> that <em>just</em> operates on the AST—or rather, on a JSON representation of the AST that pandoc can produce and consume:</p>
<pre><code>                         source format
                              ↓
                           (pandoc)
                              ↓
                      JSON-formatted AST
                              ↓
                           (filter)
                              ↓
                      JSON-formatted AST
                              ↓
                           (pandoc)
                              ↓
                        target format</code></pre>
<p>The module <code>Text.Pandoc.JSON</code> (from <code>pandoc-types</code>) contains a function <code>toJSONFilter</code> that makes it easy to write such filters. Here is a filter version of <code>behead.hs</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">#!/usr/bin/env runhaskell</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="co">-- behead2.hs</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Text.Pandoc.JSON</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">main <span class="fu">=</span> toJSONFilter behead</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="kw">where</span> behead (<span class="dt">Header</span> n _ xs) <span class="fu">|</span> n <span class="fu">&gt;=</span> <span class="dv">2</span> <span class="fu">=</span> <span class="dt">Para</span> [<span class="dt">Emph</span> xs]</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">        behead x <span class="fu">=</span> x</a></code></pre></div>
<p>It can be used this way:</p>
<pre><code>pandoc -f SOURCEFORMAT -t json | runhaskell behead2.hs | \
  pandoc -f json -t TARGETFORMAT</code></pre>
<p>But it is easier to use the <code>--filter</code> option with pandoc:</p>
<pre><code>pandoc -f SOURCEFORMAT -t TARGETFORMAT --filter ./behead2.hs</code></pre>
<p>Note that this approach requires that <code>behead2.hs</code> be executable, so we must</p>
<pre><code>chmod +x behead2.hs</code></pre>
<p>Alternatively, we could compile the filter:</p>
<pre><code>ghc --make behead2.hs
pandoc -f SOURCEFORMAT -t TARGETFORMAT --filter ./behead</code></pre>
<p>Note that if the filter is placed in the system PATH, then the initial <code>./</code> is not needed. Note also that the command line can include multiple instances of <code>--filter</code>: the filters will be applied in sequence.</p>
<h1 id="latex-for-wordpress">LaTeX for WordPress</h1>
<p>Another easy example. WordPress blogs require a special format for LaTeX math. Instead of <code>$e=mc^2$</code>, you need: <code>$LaTeX e=mc^2$</code>. How can we convert a markdown document accordingly?</p>
<p>Again, it’s difficult to do the job reliably with regexes. A <code>$</code> might be a regular currency indicator, or it might occur in a comment or code block or inline code span. We just want to find the <code>$</code>s that begin LaTeX math. If only we had a parser…</p>
<p>We do. Pandoc already extracts LaTeX math, so:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">#!/usr/bin/env runhaskell</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="co">-- wordpressify.hs</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Text.Pandoc.JSON</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">main <span class="fu">=</span> toJSONFilter wordpressify</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">  <span class="kw">where</span> wordpressify (<span class="dt">Math</span> x y) <span class="fu">=</span> <span class="dt">Math</span> x (<span class="st">&quot;LaTeX &quot;</span> <span class="fu">++</span> y)</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">        wordpressify x <span class="fu">=</span> x</a></code></pre></div>
<p>Mission accomplished. (I’ve omitted type signatures here, just to show it can be done.)</p>
<h1 id="but-i-dont-want-to-learn-haskell">But I don’t want to learn Haskell!</h1>
<p>While it’s easiest to write pandoc filters in Haskell, it is fairly easy to write them in python using the <code>pandocfilters</code> package. The package is in PyPI and can be installed using <code>pip install pandocfilters</code> or <code>easy_install pandocfilters</code>.</p>
<p>Here’s our “beheading” filter in python:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">#!/usr/bin/env python</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="co">Pandoc filter to convert all level 2+ headers to paragraphs with</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="co">emphasized text.</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="im">from</span> pandocfilters <span class="im">import</span> toJSONFilter, Emph, Para</a>
<a class="sourceLine" id="cb17-9" data-line-number="9"></a>
<a class="sourceLine" id="cb17-10" data-line-number="10"><span class="kw">def</span> behead(key, value, <span class="bu">format</span>, meta):</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">  <span class="cf">if</span> key <span class="op">==</span> <span class="st">&#39;Header&#39;</span> <span class="kw">and</span> value[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    <span class="cf">return</span> Para([Emph(value[<span class="dv">2</span>])])</a>
<a class="sourceLine" id="cb17-13" data-line-number="13"></a>
<a class="sourceLine" id="cb17-14" data-line-number="14"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">  toJSONFilter(behead)</a></code></pre></div>
<p><code>toJSONFilter(behead)</code> walks the AST and applies the <code>behead</code> action to each element. If <code>behead</code> returns nothing, the node is unchanged; if it returns an object, the node is replaced; if it returns a list, the new list is spliced in.</p>
<p>Note that, although these parameters are not used in this example, <code>format</code> provides access to the target format, and <code>meta</code> provides access to the document’s metadata.</p>
<p>There are many examples of python filters in <a href="http://github.com/jgm/pandocfilters">the pandocfilters repository</a>.</p>
<p>For a more Pythonic alternative to pandocfilters, see the <a href="http://scorreia.com/software/panflute/">panflute</a> library. Don’t like Python? There are also ports of pandocfilters in <a href="https://github.com/vinai/pandocfilters-php">PHP</a>, <a href="https://metacpan.org/pod/Pandoc::Filter">perl</a>, <a href="https://github.com/mvhenderson/pandoc-filter-node">javascript/node.js</a>, <a href="https://github.com/dfrommi/groovy-pandoc">Groovy</a>, and <a href="https://heerdebeer.org/Software/markdown/paru/">Ruby</a>.</p>
<p>Starting with pandoc 2.0, pandoc includes built-in support for writing filters in lua. The lua interpreter is built in to pandoc, so a lua filter does not require any additional software to run. See the <a href="lua-filters.html">documentation on lua filters</a>.</p>
<h1 id="include-files">Include files</h1>
<p>So none of our transforms have involved IO. How about a script that reads a markdown document, finds all the inline code blocks with attribute <code>include</code>, and replaces their contents with the contents of the file given?</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">#!/usr/bin/env runhaskell</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="co">-- includes.hs</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Text.Pandoc.JSON</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="ot">doInclude ::</span> <span class="dt">Block</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Block</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">doInclude cb<span class="fu">@</span>(<span class="dt">CodeBlock</span> (id, classes, namevals) contents) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">  <span class="kw">case</span> lookup <span class="st">&quot;include&quot;</span> namevals <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">       <span class="dt">Just</span> f     <span class="ot">-&gt;</span> return <span class="fu">.</span> (<span class="dt">CodeBlock</span> (id, classes, namevals)) <span class="fu">=&lt;&lt;</span> readFile f</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">       <span class="dt">Nothing</span>    <span class="ot">-&gt;</span> return cb</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">doInclude x <span class="fu">=</span> return x</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">main <span class="fu">=</span> toJSONFilter doInclude</a></code></pre></div>
<p>Try this on the following:</p>
<pre><code>Here&#39;s the pandoc README:

~~~~ {include=&quot;README&quot;}
this will be replaced by contents of README
~~~~</code></pre>
<h1 id="removing-links">Removing links</h1>
<p>What if we want to remove every link from a document, retaining the link’s text?</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">#!/usr/bin/env runhaskell</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="co">-- delink.hs</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Text.Pandoc.JSON</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">main <span class="fu">=</span> toJSONFilter delink</a>
<a class="sourceLine" id="cb20-6" data-line-number="6"></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="ot">delink ::</span> <span class="dt">Inline</span> <span class="ot">-&gt;</span> [<span class="dt">Inline</span>]</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">delink (<span class="dt">Link</span> _ txt _) <span class="fu">=</span> txt</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">delink x              <span class="fu">=</span> [x]</a></code></pre></div>
<p>Note that <code>delink</code> can’t be a function of type <code>Inline -&gt; Inline</code>, because the thing we want to replace the link with is not a single <code>Inline</code> element, but a list of them. So we make <code>delink</code> a function from an <code>Inline</code> element to a list of <code>Inline</code> elements. <code>toJSONFilter</code> can still lift this function to a transformation of type <code>Pandoc -&gt; Pandoc</code>.</p>
<h1 id="a-filter-for-ruby-text">A filter for ruby text</h1>
<p>Finally, here’s a nice real-world example, developed on the <a href="http://groups.google.com/group/pandoc-discuss/browse_thread/thread/7baea325565878c8">pandoc-discuss</a> list. Qubyte wrote:</p>
<blockquote>
<p>I’m interested in using pandoc to turn my markdown notes on Japanese into nicely set HTML and (Xe)LaTeX. With HTML5, ruby (typically used to phonetically read chinese characters by placing text above or to the side) is standard, and support from browsers is emerging (Webkit based browsers appear to fully support it). For those browsers that don’t support it yet (notably Firefox) the feature falls back in a nice way by placing the phonetic reading inside brackets to the side of each Chinese character, which is suitable for other output formats too. As for (Xe)LaTeX, ruby is not an issue.</p>
<p>At the moment, I use inline HTML to achieve the result when the conversion is to HTML, but it’s ugly and uses a lot of keystrokes, for example</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">&lt;ruby&gt;</span>ご<span class="kw">&lt;rt&gt;&lt;/rt&gt;</span>飯<span class="kw">&lt;rp&gt;</span>（&lt;/rp&gt;<span class="kw">&lt;rt&gt;</span>はん<span class="kw">&lt;/rt&gt;&lt;rp&gt;</span>）&lt;/rp&gt;<span class="kw">&lt;/ruby&gt;</span></a></code></pre></div>
<p>sets ご飯 “gohan” with “han” spelt phonetically above the second character, or to the right of it in brackets if the browser does not support ruby. I’d like to have something more like</p>
<pre><code>r[はん](飯)</code></pre>
<p>or any keystroke saving convention would be welcome.</p>
</blockquote>
<p>We came up with the following script, which uses the convention that a markdown link with a URL beginning with a hyphen is interpreted as ruby:</p>
<pre><code>[はん](-飯)</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="co">-- handleruby.hs</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Text.Pandoc.JSON</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4"></a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="ot">handleRuby ::</span> <span class="dt">Maybe</span> <span class="dt">Format</span> <span class="ot">-&gt;</span> <span class="dt">Inline</span> <span class="ot">-&gt;</span> <span class="dt">Inline</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">handleRuby (<span class="dt">Just</span> format) (<span class="dt">Link</span> _ [<span class="dt">Str</span> ruby] (<span class="ch">&#39;-&#39;</span><span class="fu">:</span>kanji,_))</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  <span class="fu">|</span> format <span class="fu">==</span> <span class="dt">Format</span> <span class="st">&quot;html&quot;</span>  <span class="fu">=</span> <span class="dt">RawInline</span> format</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">    <span class="fu">$</span> <span class="st">&quot;&lt;ruby&gt;&quot;</span> <span class="fu">++</span> kanji <span class="fu">++</span> <span class="st">&quot;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;&quot;</span> <span class="fu">++</span> ruby <span class="fu">++</span> <span class="st">&quot;&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&quot;</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  <span class="fu">|</span> format <span class="fu">==</span> <span class="dt">Format</span> <span class="st">&quot;latex&quot;</span> <span class="fu">=</span> <span class="dt">RawInline</span> format</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">    <span class="fu">$</span> <span class="st">&quot;\\ruby{&quot;</span> <span class="fu">++</span> kanji <span class="fu">++</span> <span class="st">&quot;}{&quot;</span> <span class="fu">++</span> ruby <span class="fu">++</span> <span class="st">&quot;}&quot;</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Str</span> ruby</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">handleRuby _ x <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb24-13" data-line-number="13"></a>
<a class="sourceLine" id="cb24-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb24-15" data-line-number="15">main <span class="fu">=</span> toJSONFilter handleRuby</a></code></pre></div>
<p>Note that, when a script is called using <code>--filter</code>, pandoc passes it the target format as the first argument. When a function’s first argument is of type <code>Maybe Format</code>, <code>toJSONFilter</code> will automatically assign it <code>Just</code> the target format or <code>Nothing</code>.</p>
<p>We compile our script:</p>
<pre><code>ghc --make handleRuby</code></pre>
<p>Then run it:</p>
<pre><code>% pandoc -F ./handleRuby -t html
[はん](-飯)
^D
&lt;p&gt;&lt;ruby&gt;飯&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;はん&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/p&gt;
% pandoc -F ./handleRuby -t latex
[はん](-飯)
^D
\ruby{飯}{はん}</code></pre>
<h1 id="exercises">Exercises</h1>
<ol type="1">
<li><p>Put all the regular text in a markdown document in ALL CAPS (without touching text in URLs or link titles).</p></li>
<li><p>Remove all horizontal rules from a document.</p></li>
<li><p>Renumber all enumerated lists with roman numerals.</p></li>
<li><p>Replace each delimited code block with class <code>dot</code> with an image generated by running <code>dot -Tpng</code> (from graphviz) on the contents of the code block.</p></li>
<li><p>Find all code blocks with class <code>python</code> and run them using the python interpreter, printing the results to the console.</p></li>
</ol>
        </div>
      </main>
    </div>
    <footer>
    </footer>
  </div>
</body>
</html>
